<?xml version="1.0" encoding="UTF-8"?>

<!-- This file is part of the book                -->
<!--                                              -->
<!--      A First Course in Linear Algebra        -->
<!--                                              -->
<!-- Copyright (C) 2004-2017  Robert A. Beezer    -->
<!-- See the file COPYING for copying conditions. -->

<section xml:id="section-O" acro="O">
    <title>Orthogonality</title>
    <introduction>
        <p>In this section we define a couple more operations with vectors, and prove a few theorems.  At first blush these definitions and results will not appear central to what follows, but we will make use of them at key points in the remainder of the course (such as <xref ref="section-MINM" acro="MINM"/>, <xref ref="section-OD" acro="OD"/>).  Because we have chosen to use <m>\complexes</m> as our set of scalars, this subsection is a bit more, uh, <ellipsis/> complex than it would be for the real numbers.  We will explain as we go along how things get easier for the real numbers <m>{\mathbb R}</m>.  If you have not already, now would be a good time to review some of the basic properties of arithmetic with complex numbers described in <xref ref="section-CNO" acro="CNO"/>.  With that done, we can extend the basics of complex number arithmetic to our study of vectors in <m>\complex{m}</m>.</p>
    </introduction>
    <subsection xml:id="subsection-O-CAV" acro="CAV">
        <title>Complex Arithmetic and Vectors</title>
        <p>We know how the addition and multiplication of complex numbers is employed in defining the operations for vectors in <m>\complex{m}</m> (<xref ref="definition-CVA" acro="CVA"/> and <xref ref="definition-CVSM" acro="CVSM"/>).  We can also extend the idea of the conjugate to vectors.</p>
        <definition xml:id="definition-CCCV" acro="CCCV">
            <title>Complex Conjugate of a Column Vector</title>
            <idx>
                <h>conjugate</h>
                <h>column vector</h>
            </idx>
            <statement>
                <p>Suppose that <m>\vect{u}</m> is a vector from <m>\complex{m}</m>.  Then the conjugate of the vector, <m>\conjugate{\vect{u}}</m>, is defined by<md>
                    <mrow>\vectorentry{\conjugate{\vect{u}}}{i}
                    &amp;=\conjugate{\vectorentry{\vect{u}}{i}}
                    &amp;&amp;1\leq i\leq m</mrow>
                </md>.</p>
            </statement>
            <notation xml:id="notation-CCCV" acro="CCCV">
                <idx>
                    <h>conjugate of a vector</h>
                    <h>notation</h>
                </idx>
                <description>Complex Conjugate of a Column Vector</description>
                <usage>\conjugate{\vect{u}}</usage>
            </notation>
        </definition>
        <p>With this definition we can show that the conjugate of a column vector behaves as we would expect with regard to vector addition and scalar multiplication.</p>
        <theorem xml:id="theorem-CRVA" acro="CRVA">
            <title>Conjugation Respects Vector Addition</title>
            <idx>
                <h>conjugate</h>
                <h>vector addition</h>
            </idx>
            <statement>
                <p>Suppose <m>\vect{x}</m> and <m>\vect{y}</m> are two vectors from <m>\complex{m}</m>.  Then<me>\conjugate{\vect{x}+\vect{y}}=\conjugate{\vect{x}}+\conjugate{\vect{y}}</me>.</p>
            </statement>
            <proof>
                <p>For each <m>1\leq i\leq m</m><md>
                    <mrow>\vectorentry{\conjugate{\vect{x}+\vect{y}}}{i}
                    &amp;=\conjugate{\vectorentry{\vect{x}+\vect{y}}{i}}&amp;&amp;
                        <xref ref="definition-CCCV" acro="CCCV"/></mrow>
                    <mrow>&amp;=\conjugate{\vectorentry{\vect{x}}{i}+\vectorentry{\vect{y}}{i}}&amp;&amp;
                        <xref ref="definition-CVA" acro="CVA"/></mrow>
                    <mrow>&amp;=\conjugate{\vectorentry{\vect{x}}{i}}+\conjugate{\vectorentry{\vect{y}}{i}}&amp;&amp;
                        <xref ref="theorem-CCRA" acro="CCRA"/></mrow>
                    <mrow>&amp;=\vectorentry{\conjugate{\vect{x}}}{i}+\vectorentry{\conjugate{\vect{y}}}{i}&amp;&amp;
                        <xref ref="definition-CCCV" acro="CCCV"/></mrow>
                    <mrow>&amp;=\vectorentry{\conjugate{\vect{x}}+\conjugate{\vect{y}}}{i}&amp;&amp;
                        <xref ref="definition-CVA" acro="CVA"/></mrow>
                </md>.</p>
                <p>Then by <xref ref="definition-CVE" acro="CVE"/> we have <m>\conjugate{\vect{x}+\vect{y}}=\conjugate{\vect{x}}+\conjugate{\vect{y}}</m>.</p>
            </proof>
        </theorem>
        <theorem xml:id="theorem-CRSM" acro="CRSM">
            <title>Conjugation Respects Vector Scalar Multiplication</title>
            <idx>
                <h>conjugate</h>
                <h>scalar multiplication</h>
            </idx>
            <statement>
                <p>Suppose <m>\vect{x}</m> is a vector from <m>\complex{m}</m>, and <m>\alpha\in\complexes</m> is a scalar.  Then<me>\conjugate{\alpha\vect{x}}=\conjugate{\alpha}\,\conjugate{\vect{x}}</me>.</p>
            </statement>
            <proof>
                <p>For <m>1\leq i\leq m</m><md>
                    <mrow>\vectorentry{\conjugate{\alpha\vect{x}}}{i}
                    &amp;=\conjugate{\vectorentry{\alpha\vect{x}}{i}}&amp;&amp;
                        <xref ref="definition-CCCV" acro="CCCV"/></mrow>
                    <mrow>&amp;=\conjugate{\alpha\vectorentry{\vect{x}}{i}}&amp;&amp;
                        <xref ref="definition-CVSM" acro="CVSM"/></mrow>
                    <mrow>&amp;=\conjugate{\alpha}\,\conjugate{\vectorentry{\vect{x}}{i}}&amp;&amp;
                        <xref ref="theorem-CCRM" acro="CCRM"/></mrow>
                    <mrow>&amp;=\conjugate{\alpha}\,\vectorentry{\conjugate{\vect{x}}}{i}&amp;&amp;
                        <xref ref="definition-CCCV" acro="CCCV"/></mrow>
                    <mrow>&amp;=\vectorentry{\conjugate{\alpha}\,\conjugate{\vect{x}}}{i}&amp;&amp;
                        <xref ref="definition-CVSM" acro="CVSM"/></mrow>
                </md>.</p>
                <p>Then by <xref ref="definition-CVE" acro="CVE"/> we have <m>\conjugate{\alpha\vect{x}}=\conjugate{\alpha}\,\conjugate{\vect{x}}</m>.</p>
            </proof>
        </theorem>
        <p>These two theorems together tell us how we can <q>push</q> complex conjugation through linear combinations.</p>
    </subsection>
    <subsection xml:id="subsection-O-IP" acro="IP">
        <title>Inner products</title>
        <definition xml:id="definition-IP" acro="IP">
            <title>Inner Product</title>
            <idx>
                <h>vector</h>
                <h>inner product</h>
            </idx>
            <statement>
                <p>Given the vectors <m>\vect{u},\,\vect{v}\in\complex{m}</m> the <term>inner product</term> of <m>\vect{u}</m> and <m>\vect{v}</m> is the scalar quantity in <m>\complexes</m><me>\innerproduct{\vect{u}}{\vect{v}}=
                \conjugate{\vectorentry{\vect{u}}{1}}\vectorentry{\vect{v}}{1}+
                \conjugate{\vectorentry{\vect{u}}{2}}\vectorentry{\vect{v}}{2}+
                \conjugate{\vectorentry{\vect{u}}{3}}\vectorentry{\vect{v}}{3}+
                \cdots+
                \conjugate{\vectorentry{\vect{u}}{m}}\vectorentry{\vect{v}}{m}
                =
                \sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}</me>.</p>
            </statement>
            <notation xml:id="notation-IP" acro="IP">
                <idx>
                    <h>inner product</h>
                    <h>notation</h>
                </idx>
                <description>Inner Product</description>
                <usage>\innerproduct{\vect{u}}{\vect{v}}</usage>
            </notation>
        </definition>
        <p>This operation is a bit different in that we begin with two vectors but produce a scalar.  Computing one is straightforward.</p>
        <example xml:id="example-CSIP" acro="CSIP">
            <title>Computing some inner products</title>
            <idx>inner product</idx>
            <p>The inner product of<md>
                <mrow>\vect{u}=\colvector{2+3i\\5+2i\\-3+i}&amp;&amp;\text{and}&amp;&amp;\vect{v}=\colvector{1+2i\\-4+5i\\0+5i}</mrow>
            </md>is<md>
                <mrow>\innerproduct{\vect{u}}{\vect{v}} &amp;=(\conjugate{2+3i})(1+2i)+(\conjugate{5+2i})(-4+5i)+(\conjugate{-3+i})(0+5i)</mrow>
                <mrow>&amp;=(2-3i)(1+2i)+(5-2i)(-4+5i)+(-3-i)(0+5i)</mrow>
                <mrow>&amp;=(8+i)+(-10+33i)+(5-15i)</mrow>
                <mrow>&amp;=3+19i</mrow>
            </md>.</p>
            <p>The inner product of<md>
                <mrow>\vect{w}=\colvector{2\\4\\-3\\2\\8}&amp;&amp;\text{and}&amp;&amp; \vect{x}=\colvector{3\\1\\0\\-1\\-2}</mrow>
            </md>is<md>
                <mrow>\innerproduct{\vect{w}}{\vect{x}}&amp;= (\conjugate{2})3+(\conjugate{4})1+(\conjugate{-3})0+(\conjugate{2})(-1)+(\conjugate{8})(-2)</mrow>
                <mrow>&amp;=2(3)+4(1)+(-3)0+2(-1)+8(-2)=-8</mrow>
            </md>.</p>
        </example>
        <p>In the case where the entries of our vectors are all real numbers (as in the second part of <xref ref="example-CSIP" acro="CSIP"/>), the computation of the inner product may look familiar and be known to you as a <term>dot product</term> or <term>scalar product</term>.  So you can view the inner product as a generalization of the scalar product to vectors from <m>\complex{m}</m> (rather than <m>{\mathbb R}^m</m>).</p>
        <p>Note that we have chosen to conjugate the entries of the <em>first</em> vector listed in the inner product, while it is almost equally feasible to conjugate entries from the <em>second</em> vector instead.  In particular, prior to Version 2.90, we did use the latter definition, and this has now changed to the former, with resulting adjustments propogated up through <xref ref="section-CB" acro="CB"/> (only).  However, conjugating the first vector leads to much nicer formulas for certain matrix decompositions and also shortens some proofs.</p>
        <p>There are several quick theorems we can now prove, and they will each be useful later.</p>
        <theorem xml:id="theorem-IPVA" acro="IPVA">
            <title>Inner Product and Vector Addition</title>
            <idx>
                <h>inner product</h>
                <h>vector addition</h>
            </idx>
            <statement>
                <p>Suppose <m>\vect{u},\,\vect{v},\,\vect{w}\in\complex{m}</m>.  Then <ol>
                    <li><m>\innerproduct{\vect{u}+\vect{v}}{\vect{w}}=\innerproduct{\vect{u}}{\vect{w}}+\innerproduct{\vect{v}}{\vect{w}}</m>.</li>
                    <li><m>\innerproduct{\vect{u}}{\vect{v}+\vect{w}}=\innerproduct{\vect{u}}{\vect{v}}+\innerproduct{\vect{u}}{\vect{w}}</m>.</li>
                </ol></p>
            </statement>
            <proof>
                <p>The proofs of the two parts are very similar, with the second one requiring just a bit more effort due to the conjugation that occurs.  We will prove part 1 and you can prove part 2 (<xref ref="exercise-O-T10" acro="O.T10"/>).<md>
                <mrow>\innerproduct{\vect{u}+\vect{v}}{\vect{w}}
                &amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}+\vect{v}}{i}}\vectorentry{\vect{w}}{i}&amp;&amp;
                    <xref ref="definition-IP" acro="IP"/></mrow>
                <mrow>&amp;=\sum_{i=1}^{m}\left(\conjugate{\vectorentry{\vect{u}}{i}+
                \vectorentry{\vect{v}}{i}}\right)\vectorentry{\vect{w}}{i}&amp;&amp;
                    <xref ref="definition-CVA" acro="CVA"/></mrow>
                <mrow>&amp;=\sum_{i=1}^{m}\left(\conjugate{\vectorentry{\vect{u}}{i}}+
                \conjugate{\vectorentry{\vect{v}}{i}}\right)\vectorentry{\vect{w}}{i}&amp;&amp;
                    <xref ref="theorem-CCRA" acro="CCRA"/></mrow>
                <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{w}}{i}
                + \conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{w}}{i}&amp;&amp;
                    <xref ref="property-DCN" acro="DCN"/></mrow>
                <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{w}}{i}
                + \sum_{i=1}^{m}\conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{w}}{i}&amp;&amp;
                    <xref ref="property-CACN" acro="CACN"/></mrow>
                <mrow>&amp;=\innerproduct{\vect{u}}{\vect{w}}+\innerproduct{\vect{v}}{\vect{w}}&amp;&amp;
                    <xref ref="definition-IP" acro="IP"/></mrow>
            </md></p>
            </proof>
        </theorem>
        <theorem xml:id="theorem-IPSM" acro="IPSM">
            <title>Inner Product and Scalar Multiplication</title>
            <idx>
                <h>inner product</h>
                <h>scalar multiplication</h>
            </idx>
            <statement>
                <p>Suppose <m>\vect{u},\,\vect{v}\in\complex{m}</m> and <m>\alpha\in\complexes</m>.  Then <ol>
                    <li><m>\innerproduct{\alpha\vect{u}}{\vect{v}}=\conjugate{\alpha}\innerproduct{\vect{u}}{\vect{v}}</m>.</li>
                    <li><m>\innerproduct{\vect{u}}{\alpha\vect{v}}=\alpha\innerproduct{\vect{u}}{\vect{v}}</m>.</li>
                </ol></p>
            </statement>
            <proof>
                <p>The proofs of the two parts are very similar, with the second one requiring just a bit more effort due to the conjugation that occurs.  We will prove part 1 and you can prove part 2  (<xref ref="exercise-O-T11" acro="O.T11"/>).<md>
                    <mrow>\innerproduct{\alpha\vect{u}}{\vect{v}}&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\alpha\vect{u}}{i}}\vectorentry{\vect{v}}{i}&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\alpha\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}&amp;&amp;
                        <xref ref="definition-CVSM" acro="CVSM"/></mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\alpha}\,\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}&amp;&amp;
                        <xref ref="theorem-CCRM" acro="CCRM"/></mrow>
                    <mrow>&amp;=\conjugate{\alpha}\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}&amp;&amp;
                        <xref ref="property-DCN" acro="DCN"/></mrow>
                    <mrow>&amp;=\conjugate{\alpha}\innerproduct{\vect{u}}{\vect{v}}&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                </md></p>
            </proof>
        </theorem>
        <theorem xml:id="theorem-IPAC" acro="IPAC">
            <title>Inner Product is Anti-Commutative</title>
            <idx>
                <h>inner product</h>
                <h>anti-commutative</h>
            </idx>
            <statement>
                <p>Suppose that <m>\vect{u}</m> and <m>\vect{v}</m> are vectors in <m>\complex{m}</m>.  Then<m>\innerproduct{\vect{u}}{\vect{v}}=\conjugate{\innerproduct{\vect{v}}{\vect{u}}}</m>.</p>
            </statement>
            <proof>
                <p><md>
                    <mrow>\innerproduct{\vect{u}}{\vect{v}}
                    &amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\,\conjugate{\conjugate{\vectorentry{\vect{v}}{i}}}&amp;&amp;
                        <xref ref="theorem-CCT" acro="CCT"/></mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}\conjugate{\vectorentry{\vect{v}}{i}}}&amp;&amp;
                        <xref ref="theorem-CCRM" acro="CCRM"/></mrow>
                    <mrow>&amp;=\conjugate{\left(\sum_{i=1}^{m}\vectorentry{\vect{u}}{i}\conjugate{\vectorentry{\vect{v}}{i}}\right)}&amp;&amp;
                        <xref ref="theorem-CCRA" acro="CCRA"/></mrow>
                    <mrow>&amp;=\conjugate{\left(\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{u}}{i}\right)}&amp;&amp;
                        <xref ref="property-CMCN" acro="CMCN"/></mrow>
                    <mrow>&amp;=\conjugate{\innerproduct{\vect{v}}{\vect{u}}}&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                </md></p>
            </proof>
        </theorem>
    </subsection>
    <subsection xml:id="subsection-O-N" acro="N">
        <title>Norm</title>
        <p>If treating linear algebra in a more geometric fashion, the length of a vector occurs naturally, and is what you would expect from its name.   With complex numbers, we will define a similar function.  Recall that if <m>c</m> is a complex number, then <m>\modulus{c}</m> denotes its modulus (<xref ref="definition-MCN" acro="MCN"/>).</p>
        <definition xml:id="definition-NV" acro="NV">
            <title>Norm of a Vector</title>
            <idx>
                <h>vector</h>
                <h>norm</h>
            </idx>
            <statement>
                <p>The <term>norm</term> of the vector <m>\vect{u}</m> is the scalar quantity in <m>\complexes</m><me>\norm{\vect{u}}=
                \sqrt{
                \modulus{\vectorentry{\vect{u}}{1}}^2+
                \modulus{\vectorentry{\vect{u}}{2}}^2+
                \modulus{\vectorentry{\vect{u}}{3}}^2+
                \cdots+
                \modulus{\vectorentry{\vect{u}}{m}}^2
                }
                =
                \sqrt{\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2}</me>.</p>
            </statement>
            <notation xml:id="notation-NV" acro="NV">
                <idx>
                    <h>norm</h>
                    <h>notation</h>
                </idx>
                <description>Norm of a Vector</description>
                <usage>\norm{\vect{v}}</usage>
            </notation>
        </definition>
        <p>Computing a norm is also easy to do.</p>
        <example xml:id="example-CNSV" acro="CNSV">
            <title>Computing the norm of some vectors</title>
            <idx>norm</idx>
            <p>The norm of<me>\vect{u}=\colvector{3+2i\\1-6i\\2+4i\\2+i}</me>is<md>
                <mrow>\norm{\vect{u}}&amp;=
                \sqrt{\modulus{3+2i}^2+\modulus{1-6i}^2+\modulus{2+4i}^2+\modulus{2+i}^2}</mrow>
                <mrow>&amp;=\sqrt{13+37+20+5}=\sqrt{75}=5\sqrt{3}</mrow>
            </md>.</p>
            <p>The norm of<me>\vect{v}=\colvector{3\\-1\\2\\4\\-3}</me>is<me>\norm{\vect{v}}=
            \sqrt{\modulus{3}^2+\modulus{-1}^2+\modulus{2}^2+\modulus{4}^2+\modulus{-3}^2}
            =\sqrt{3^2+1^2+2^2+4^2+3^2}=\sqrt{39}</me>.</p>
        </example>
        <p>Notice how the norm of a vector with real number entries is just the length of the vector.  Inner products and norms are related by the following theorem.</p>
        <theorem xml:id="theorem-IPN" acro="IPN">
            <title>Inner Products and Norms</title>
            <idx>
                <h>inner product</h>
                <h>norm</h>
            </idx>
            <statement>
                <idx>
                    <h>norm</h>
                    <h>inner product</h>
                </idx>
                <p>Suppose that <m>\vect{u}</m> is a vector in <m>\complex{m}</m>.  Then <m>\norm{\vect{u}}^2=\innerproduct{\vect{u}}{\vect{u}}</m>.</p>
            </statement>
            <proof>
                <p><md>
                    <mrow>\norm{\vect{u}}^2&amp;=\left(\sqrt{\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2}\right)^2&amp;&amp;
                        <xref ref="definition-NV" acro="NV"/></mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2&amp;&amp;\text{Inverse functions}</mrow>
                    <mrow>&amp;=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{u}}{i}&amp;&amp;
                        <xref ref="definition-MCN" acro="MCN"/></mrow>
                    <mrow>&amp;=\innerproduct{\vect{u}}{\vect{u}}&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                    </md></p>
            </proof>
        </theorem>
        <p>When our vectors have entries only from the real numbers <xref ref="theorem-IPN" acro="IPN"/> says that the dot product of a vector with itself is equal to the length of the vector squared.</p>
        <theorem xml:id="theorem-PIP" acro="PIP">
            <title>Positive Inner Products</title>
            <idx>
                <h>inner product</h>
                <h>positive</h>
            </idx>
            <statement>
                <p>Suppose that <m>\vect{u}</m> is a vector in <m>\complex{m}</m>.  Then <m>\innerproduct{\vect{u}}{\vect{u}}\geq 0</m> with equality if and only if <m>\vect{u}=\zerovector</m>.</p>
            </statement>
            <proof>
                <p>From the proof of <xref ref="theorem-IPN" acro="IPN"/>  we see that<me>\innerproduct{\vect{u}}{\vect{u}}
                =
                \modulus{\vectorentry{\vect{u}}{1}}^2+
                \modulus{\vectorentry{\vect{u}}{2}}^2+
                \modulus{\vectorentry{\vect{u}}{3}}^2+
                \cdots+
                \modulus{\vectorentry{\vect{u}}{m}}^2</me>.</p>
                <p>Since each modulus is squared, every term is positive, and the sum must also be positive.  (Notice that in general the inner product is a complex number and cannot be compared with zero, but in the special case of <m>\innerproduct{\vect{u}}{\vect{u}}</m> the result is a real number.)</p>
                <p>The phrase, <q>with equality if and only if</q> means that we want to show that the statement <m>\innerproduct{\vect{u}}{\vect{u}}= 0</m> (<ie/> with equality) is equivalent (<q>if and only if</q>) to the statement <m>\vect{u}=\zerovector</m>.</p>
                <p>If <m>\vect{u}=\zerovector</m>, then it is a straightforward computation to see that <m>\innerproduct{\vect{u}}{\vect{u}}= 0</m>.  In the other direction, assume that <m>\innerproduct{\vect{u}}{\vect{u}}= 0</m>.  As before, <m>\innerproduct{\vect{u}}{\vect{u}}</m> is a sum of moduli.  So we have<me>0=\innerproduct{\vect{u}}{\vect{u}}=
                \modulus{\vectorentry{\vect{u}}{1}}^2+
                \modulus{\vectorentry{\vect{u}}{2}}^2+
                \modulus{\vectorentry{\vect{u}}{3}}^2+
                \cdots+
                \modulus{\vectorentry{\vect{u}}{m}}^2</me></p>
                <p>Now we have a sum of squares equaling zero, so each term must be zero.  Then by similar logic, <m>\modulus{\vectorentry{\vect{u}}{i}}=0</m> will imply that <m>\vectorentry{\vect{u}}{i}=0</m>, since <m>0+0i</m> is the only complex number with zero modulus.  Thus every entry of <m>\vect{u}</m> is zero and so <m>\vect{u}=\zerovector</m>, as desired.</p>
            </proof>
        </theorem>
        <p>Notice that <xref ref="theorem-PIP" acro="PIP"/> contains <em>three</em> implications<md>
            <mrow>\vect{u}\in\complex{m}&amp;\Rightarrow\innerproduct{\vect{u}}{\vect{u}}\geq 0
            &amp;
            \vect{u}=\zerovector&amp;\Rightarrow\innerproduct{\vect{u}}{\vect{u}}=0
            &amp;
            \innerproduct{\vect{u}}{\vect{u}}=0&amp;\Rightarrow\vect{u}=\zerovector</mrow>
        </md>.</p>
        <p>The results contained in <xref ref="theorem-PIP" acro="PIP"/> are summarized by saying <q>the inner product is <term>positive definite</term>.</q></p>
        <computation xml:id="sage-EVIC" acro="EVIC">
            <title>Exact Versus Inexact Computations</title>
            <idx>exact vs.\ inexact computations</idx>
            <p>We are now at a crossroads in our use of Sage.  So far our computations have involved rational numbers: fractions of two integers.  Sage is able to work with integers of seemingly unlimited size, and then can work with rational numbers exactly.  So all of our computations have been exactly correct so far.  In practice, many computations, especially those that originate with data, are not so precise.  Then we <em>represent</em> real numbers by <term>floating point numbers</term>.  Since the real numbers are infinite, finite computers must fake it with an extremely large, but still finite, collection of numbers.  The price we pay is that some computations will be just slightly imprecise when there is no number available that represents the exact answer.</p>
            <p>You should now appreciate two problems that occur.  If we were to row-reduce a matrix with floating point numbers, there are potentially many computations and if a small amount of imprecision arises in each one, these errors can accumulate and lead to wildly incorrect answers.  When we row-reduce a matrix, whether or not an entry is zero or not is critically important in the decisions we make about which row operation to perform.  If we have an extremely small number, such as <m>10^{-16}</m>, how can we be sure if it is zero or not?</p>
            <p>Why discuss this now?  What is <m>\alpha=\sqrt{7/3}</m>?  Hard to say exactly, but it is definitely not a rational number.  Norms of vectors will feature prominently in all our discussions about orthogonal vectors, so we now have to recognize the need to work with square roots properly.  We have two strategies in Sage.</p>
            <p>The number system <c>QQbar</c>, also known as the <term>field of algebraic numbers</term>, is a truly amazing feature of Sage.  It contains the rational numbers, plus <em>every</em> root of <em>every</em> polynomial with coefficients that are rational numbers.  For example, notice that <m>\alpha</m> above is one solution to the polynomial equation <m>3x^2-7=0</m> and thus is a number in <c>QQbar</c>, so Sage can work with it <em>exactly</em>.  These numbers are called <q>algebraic numbers</q> and you can recognize them since they print with a question mark near the end to remind you that when printed as a decimal they are approximations of numbers that Sage carries internally as exact quantities.  For example <m>\alpha</m> can be created with <c>QQbar(sqrt(7/3))</c> and will print as <c>1.527525231651947</c>?.  Notice that complex numbers begin with the introduction of the imaginary number <m>i</m>, which is a root of the polynomial equation <m>x^2+1=0</m>, so the field of algebraic numbers contains many complex numbers.  The downside of <c>QQbar</c> is that computations are slow (relatively speaking), so this number system is most useful for examples and demonstrations.</p>
            <p>The other strategy is to work strictly with approximate numbers, cognizant of the potential for inaccuracies.  Sage has two such number systems: <c>RDF</c> and <c>CDF</c>, which are comprised of <term>double precision</term> floating point numbers, first limited to just the reals, then expanded to the complexes.  Double-precision refers to the use of 64 bits to store the sign, mantissa and exponent in the representation of a real number.  This gives 53 bits of precision.  Do not confuse these fields with <c>RR</c> and <c>CC</c>, which are similar in appearance but very different in implementation.  Sage has implementations of several computations designed exclusively for <c>RDF</c> and <c>CDF</c>, such as the norm.  And they are very, very fast.  But some computations, like echelon form, can be wildly unreliable with these approximate numbers.  We will have more to say about this as we go.  In practice, you can use <c>CDF</c>, since <c>RDF</c> is a subset and only different in very limited cases.</p>
            <p>In summary, <c>QQbar</c> is an extension of <c>QQ</c> which allows exact computations, but can be slow for large examples.  <c>RDF</c> and <c>CDF</c> are fast, with special algorithms to control much of the imprecision in some, but not all, computations.  So we need to be vigilant and skeptical when we work with these approximate numbers.  We will use both strategies, as appropriate.</p>
        </computation>
        <computation xml:id="sage-CNIP" acro="CNIP">
            <title>Conjugates, Norms and Inner Products</title>
            <idx>conjugates, norms, inner products</idx>
            <p>Conjugates, of complex numbers and of vectors, are straightforward, in <c>QQbar</c> or in <c>CDF</c>.</p>
            <sage xml:id="sagecell-CNIP-1">
                <input>
                alpha = QQbar(2 + 3*I)
                alpha.conjugate()
                </input>
                <output>
                2 - 3*I
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-2">
                <input>
                beta = CDF(2+3*I)
                beta.conjugate()
                </input>
                <output>
                2.0 - 3.0*I
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-3">
                <input>
                v = vector(QQbar, [5-3*I, 2+6*I])
                v.conjugate()
                </input>
                <output>
                (5 + 3*I, 2 - 6*I)
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-4">
                <input>
                w = vector(CDF, [5-3*I, 2+6*I])
                w.conjugate()
                </input>
                <output>
                (5.0 + 3.0*I, 2.0 - 6.0*I)
                </output>
            </sage>
            <p>The term <term>inner product</term> means slightly different things to different people.  For some, it is the <term>dot product</term> that you may have seen in a calculus or physics course.  Our inner product could be called the <term>Hermitian inner product</term> to emphasize the use of vectors over the complex numbers and conjugating some of the entries.  So Sage has a <c>.dot_product()</c>, <c>.inner_product()</c>, and <c>.hermitian_inner_product()</c> <mdash/> we want to use the last one.</p>
            <p>From now on, when we mention an inner product in the context of using Sage, we will mean <c>.hermitian_inner_product()</c>.  We will redo the first part of <xref ref="example-CSIP" acro="CSIP"/>.  Notice that the syntax is a bit asymmetric.</p>
            <sage xml:id="sagecell-CNIP-5">
                <input>
                u = vector(QQbar, [2+3*I,  5+2*I, -3+I])
                v = vector(QQbar, [1+2*I, -4+5*I,  5*I])
                u.hermitian_inner_product(v)
                </input>
                <output>
                3 + 19*I
                </output>
            </sage>
            <p>Norms are as easy as conjugates.  Easier maybe.  It might be useful to realize that Sage uses entirely distinct code to compute an exact norm over <c>QQbar</c> versus an approximate norm over <c>CDF</c>, though that is totally transparent as you issue commands.  Here is <xref ref="example-CNSV" acro="CNSV"/> reprised.</p>
            <sage xml:id="sagecell-CNIP-6">
                <input>
                entries = [3+2*I, 1-6*I, 2+4*I, 2+I]
                u = vector(QQbar, entries)
                u.norm()
                </input>
                <output>
                8.66025403784439?
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-7">
                <input>
                u = vector(CDF, entries)
                u.norm()
                </input>
                <output>
                8.66025403784
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-8">
                <input>
                numerical_approx(5*sqrt(3), digits = 30)
                </input>
                <output>
                8.66025403784438646763723170753
                </output>
            </sage>
            <p>We have three different numerical approximations, the latter 30-digit number being an approximation to the answer in the text.  But there is no inconsistency between them.  The first, an algebraic number, is represented internally as <m>5*a</m> where <m>a</m> is a root of the polynomial equation <m>x^2-3=0</m>, in other words it is <m>5\sqrt{3}</m>.  The <c>CDF</c> value prints with a few digits less than what is carried internally.  Notice that our different definitions of the inner product make no difference in the computation of a norm.</p>
            <p>One warning now that we are working with complex numbers.  It is easy to <q>clobber</q> the symbol <c>I</c> used for the imaginary number <m>i</m>.  In other words, Sage will allow you to assign it to something else, rendering it useless.  An identity matrix is a likely reassignment.  If you run the next compute cell, be sure to evaluate the compute cell afterward to restore <c>I</c> to its usual role.</p>
            <sage xml:id="sagecell-CNIP-9">
                <input>
                alpha = QQbar(5 - 6*I)
                I = identity_matrix(2)
                beta = QQbar(2+5*I)
                </input>
                <output>
                Traceback (most recent call last):
                ...
                TypeError: Illegal initializer for algebraic number
                </output>
            </sage>
            <sage xml:id="sagecell-CNIP-10">
                <input>
                restore()
                I^2
                </input>
                <output>
                -1
                </output>
            </sage>
            <p>We will finish with a verification of <xref ref="theorem-IPN" acro="IPN"/>.  To test equality it is best if we work with entries from <c>QQbar</c>.</p>
            <sage xml:id="sagecell-CNIP-11">
                <input>
                v = vector(QQbar, [2-3*I, 9+5*I, 6+2*I, 4-7*I])
                v.hermitian_inner_product(v) == v.norm()^2
                </input>
                <output>
                True
                </output>
            </sage>
        </computation>
    </subsection>
    <subsection xml:id="subsection-O-OV" acro="OV">
        <title>Orthogonal Vectors</title>
        <p><term>Orthogonal</term> is a generalization of <term>perpendicular</term>.  You may have used mutually perpendicular vectors in a physics class, or you may recall from a calculus class that perpendicular vectors have a zero dot product.  We will now extend these ideas into the realm of higher dimensions and complex scalars.</p>
        <definition xml:id="definition-OV" acro="OV">
            <title>Orthogonal Vectors</title>
            <idx>
                <h>orthogonal</h>
                <h>vector pairs</h>
            </idx>
            <statement>
                <p>A pair of vectors, <m>\vect{u}</m> and <m>\vect{v}</m>, from <m>\complex{m}</m> are <term>orthogonal</term> if their inner product is zero, that is, <m>\innerproduct{\vect{u}}{\vect{v}}=0</m>.</p>
            </statement>
        </definition>
        <example xml:id="example-TOV" acro="TOV">
            <title>Two orthogonal vectors</title>
            <idx>orthogonal vectors</idx>
            <p>The vectors<md>
                <mrow>\vect{u}&amp;=\colvector{2 + 3i\\4 - 2i\\1 + i\\1 + i}
                &amp;
                \vect{v}&amp;=\colvector{1 - i\\2 + 3i\\4 - 6i\\1}</mrow>
            </md>are orthogonal since<md>
                <mrow>\innerproduct{\vect{u}}{\vect{v}}
                &amp;=(2-3i)(1-i)+(4+2i)(2+3i)+(1-i)(4-6i)+(1-i)(1)</mrow>
                <mrow>&amp;=(-1-5i)+(2+16i)+(-2-10i)+(1-i)</mrow>
                <mrow>&amp;=0+0i</mrow>
            </md>.</p>
        </example>
        <p>We extend this definition to whole sets by requiring vectors to be pairwise orthogonal.  Despite using the same word, careful thought about what objects you are using will eliminate any source of confusion.</p>
        <definition xml:id="definition-OSV" acro="OSV">
            <title>Orthogonal Set of Vectors</title>
            <idx>
                <h>orthogonal</h>
                <h>set of vectors</h>
            </idx>
            <statement>
                <p>Suppose that <m>S=\set{\vectorlist{u}{n}}</m> is a set of vectors from <m>\complex{m}</m>.  Then <m>S</m> is an <term>orthogonal set</term> if every pair of different vectors from <m>S</m> is orthogonal, that is <m>\innerproduct{\vect{u}_i}{\vect{u}_j}=0</m> whenever <m>i\neq j</m>.</p>
            </statement>
        </definition>
        <!-- TODO: Need a good example right here -->
        <p>We now define the prototypical orthogonal set, which we will reference repeatedly.</p>
        <definition xml:id="definition-SUV" acro="SUV">
            <title>Standard Unit Vectors</title>
            <idx>unit vectors</idx>
            <statement>
                <p>Let <m>\vect{e}_j\in\complex{m}</m>, <m>1\leq j\leq m</m> denote the column vectors defined by<me>\vectorentry{\vect{e}_j}{i}=
                \begin{cases}
                0&amp;\text{if }i\neq j\\
                1&amp;\text{if }i=j
                \end{cases}</me>.  Then the set<md>
                    <mrow>\set{\vectorlist{e}{m}}&amp;=\setparts{\vect{e}_j}{1\leq j\leq m}</mrow>
                </md>is the set of <term>standard unit vectors</term> in <m>\complex{m}</m>.</p>
            </statement>
            <notation xml:id="notation-SUV" acro="SUV">
                <idx>
                    <h>standard unit vector</h>
                    <h>notation</h>
                </idx>
                <description>Standard Unit Vectors</description>
                <usage>\vect{e}_i</usage>
            </notation>
        </definition>
        <p>Notice that <m>\vect{e}_j</m> is identical to column <m>j</m> of the <m>m\times m</m> identity matrix <m>I_m</m> (<xref ref="definition-IM" acro="IM"/>) and is a pivot column for <m>I_m</m>, since the identity matrix is in reduced row-echelon form.  These observations will often be useful.  We will reserve the notation <m>\vect{e}_i</m> for these vectors.  It is not hard to see that the set of standard unit vectors is an orthogonal set.</p>
        <example xml:id="example-SUVOS" acro="SUVOS">
            <title>Standard Unit Vectors are an Orthogonal Set</title>
            <idx>
                <h>unit vectors</h>
                <h>orthogonal</h>
            </idx>
            <p>Compute the inner product of two distinct vectors from the set of standard unit vectors (<xref ref="definition-SUV" acro="SUV"/>), say <m>\vect{e}_i</m>, <m>\vect{e}_j</m>, where <m>i\neq j</m><md>
                <mrow>\innerproduct{\vect{e}_i}{\vect{e}_j}&amp;=
                \conjugate{0}0+
                \conjugate{0}0+\cdots+
                \conjugate{1}0+\cdots+
                \conjugate{0}0+\cdots+
                \conjugate{0}1+\cdots+
                \conjugate{0}0+
                \conjugate{0}0</mrow>
                <mrow>&amp;=0(0)+0(0)+\cdots+1(0)+\cdots+0(1)+\cdots+0(0)+0(0)</mrow>
                <mrow>&amp;=0</mrow>
            </md>.</p>
            <p>So the set <m>\set{\vectorlist{e}{m}}</m> is an orthogonal set.</p>
        </example>
        <!--  Next example output (rescaled) from: -->
        <!--  GramSchmidt[{{1+I,1, 1-I,I},{I,1+I,-1, -I}, {I,-I, -1+I,1}, {-1-I,I,1,-1}}, -->
        <!--  InnerProduct(arrow)(Conjugate[#1].#2&)]//Simplify -->
        <example xml:id="example-AOS" acro="AOS">
            <title>An orthogonal set</title>
            <idx>
                <h>orthogonal</h>
                <h>set</h>
            </idx>
            <p>The set<me>\set{\vect{x}_1,\,\vect{x}_2,\,\vect{x}_3,\,\vect{x}_4}=
            \set{
            \colvector{1+i\\1\\1-i\\i},\,
            \colvector{1+5i\\6+5i\\-7-i\\1-6i},\,
            \colvector{-7+34i\\-8-23i\\-10+22i\\30+13i},\,
            \colvector{-2-4i\\6+i\\4+3i\\6-i}
            }</me>is an orthogonal set.</p>
            <p>Since the inner product is anti-commutative (<xref ref="theorem-IPAC" acro="IPAC"/>) we can test pairs of different vectors in any order.  If the result is zero, then it will also be zero if the inner product is computed in the opposite order.  This means there are six different pairs of vectors to use in an inner product computation.  We will do two and you can practice your inner products on the other four.<md>
                <mrow>\innerproduct{\vect{x}_1}{\vect{x}_3}&amp;=
                (1-i)(-7+34i)+(1)(-8-23i)+(1+i)(-10+22i)+(-i)(30+13i)</mrow>
                <mrow>&amp;=(27+41i)+(-8-23i)+(-32+12i)+(13-30i)</mrow>
                <mrow>&amp;=0+0i</mrow>
                <intertext>and</intertext>
                <mrow>\innerproduct{\vect{x}_2}{\vect{x}_4}&amp;=
                (1-5i)(-2-4i)+(6-5i)(6+i)+(-7+i)(4+3i)+(1+6i)(6-i)</mrow>
                <mrow>&amp;=(-22+6i)+(41-24i)+(-31-17i)+(12+35i)</mrow>
                <mrow>&amp;=0+0i</mrow>
            </md>.</p>
        </example>
        <p>So far, this section has seen lots of definitions, and lots of theorems establishing un-surprising consequences of those definitions.  But here is our first theorem that suggests that inner products and orthogonal vectors have some utility.  It is also one of our first illustrations of how to arrive at linear independence as the conclusion of a theorem.</p>
        <theorem xml:id="theorem-OSLI" acro="OSLI">
            <title>Orthogonal Sets are Linearly Independent</title>
            <idx>
                <h>orthogonal</h>
                <h>linear independence</h>
            </idx>
            <idx>
                <h>linear independence</h>
                <h>orthogonal</h>
            </idx>
            <statement>
                <p>Suppose that <m>S</m> is an orthogonal set of nonzero vectors.  Then <m>S</m> is linearly independent.</p>
            </statement>
            <proof>
                <p>Let <m>S=\set{\vectorlist{u}{n}}</m> be an orthogonal set of nonzero vectors.  To prove the linear independence of <m>S</m>, we can appeal to the definition (<xref ref="definition-LICV" acro="LICV"/>) and begin with an arbitrary relation of linear dependence (<xref ref="definition-RLDCV" acro="RLDCV"/>)<me>\lincombo{\alpha}{u}{n}=\zerovector</me>.</p>
                <p>Then, for every <m>1\leq i\leq n</m>, we have<md>
                    <mrow>&amp;\alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}</mrow>
                    <mrow>&amp;\quad\quad=\alpha_1(0)+\alpha_2(0)+\cdots+\alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}+\cdots+\alpha_n(0)&amp;&amp;
                        <xref ref="property-ZCN" acro="ZCN"/></mrow>
                    <mrow>&amp;\quad\quad=
                    \alpha_1\innerproduct{\vect{u}_i}{\vect{u}_1}+
                    \cdots+
                    \alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}+
                    \cdots+
                    \alpha_n\innerproduct{\vect{u}_i}{\vect{u}_n}&amp;&amp;
                    <xref ref="definition-OSV" acro="OSV"/></mrow>
                    <mrow>&amp;\quad\quad=
                    \innerproduct{\vect{u}_i}{\alpha_1\vect{u}_1}+
                    \innerproduct{\vect{u}_i}{\alpha_2\vect{u}_2}+
                    \cdots+
                    \innerproduct{\vect{u}_i}{\alpha_n\vect{u}_n}&amp;&amp;
                        <xref ref="theorem-IPSM" acro="IPSM"/></mrow>
                    <mrow>&amp;\quad\quad=\innerproduct{\vect{u}_i}{\lincombo{\alpha}{u}{n}}&amp;&amp;
                        <xref ref="theorem-IPVA" acro="IPVA"/></mrow>
                    <mrow>&amp;\quad\quad=\innerproduct{\vect{u}_i}{\zerovector}&amp;&amp;
                        <xref ref="definition-RLDCV" acro="RLDCV"/></mrow>
                    <mrow>&amp;\quad\quad=0&amp;&amp;
                        <xref ref="definition-IP" acro="IP"/></mrow>
                </md>.</p>
                <p>Because <m>\vect{u}_i</m> was assumed to be nonzero, <xref ref="theorem-PIP" acro="PIP"/> says <m>\innerproduct{\vect{u}_i}{\vect{u}_i}</m> is nonzero and thus <m>\alpha_i</m> must be zero.  So we conclude that <m>\alpha_i=0</m> for all <m>1\leq i\leq n</m> in any relation of linear dependence on <m>S</m>.  But this says that <m>S</m> is a linearly independent set since the only way to form a relation of linear dependence is the trivial way (<xref ref="definition-LICV" acro="LICV"/>).  Boom!</p>
            </proof>
        </theorem>
    </subsection>
    <subsection xml:id="subsection-O-GSP" acro="GSP">
        <title>Gram-Schmidt Procedure</title>
        <p>The Gram-Schmidt Procedure is really a theorem.  It says that if we begin with a linearly independent set of <m>p</m> vectors, <m>S</m>, then we can do a number of calculations with these vectors and produce an orthogonal set of <m>p</m> vectors, <m>T</m>, so that <m>\spn{S}=\spn{T}</m>.  Given the large number of computations involved, it is indeed a procedure to do all the necessary computations, and it is best employed on a computer.  However, it also has value in proofs where we may on occasion wish to replace a linearly independent set by an orthogonal set.</p>
        <p>This is our first occasion to use the technique of <term>mathematical induction</term> for a proof, a technique we will see again several times, especially in <xref ref="chapter-D" acro="D"/>.  So study the simple example described in Proof Technique<nbsp/><xref ref="technique-I" acro="I" text="global"/> first.</p>
        <theorem xml:id="theorem-GSP" acro="GSP">
            <title>Gram-Schmidt Procedure</title>
            <idx>
                <h>Gram-Schmidt</h>
                <h>column vectors</h>
            </idx>
            <statement>
                <p>Suppose that <m>S=\set{\vectorlist{v}{p}}</m> is a linearly independent set of vectors in <m>\complex{m}</m>.  Define the vectors <m>\vect{u}_i</m>, <m>1\leq i\leq p</m> by<me>\vect{u}_i=\vect{v}_i
                -\frac{\innerproduct{\vect{u}_1}{\vect{v}_i}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                -\frac{\innerproduct{\vect{u}_2}{\vect{v}_i}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
                -\frac{\innerproduct{\vect{u}_3}{\vect{v}_i}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
                -\cdots
                -\frac{\innerproduct{\vect{u}_{i-1}}{\vect{v}_i}}{\innerproduct{\vect{u}_{i-1}}{\vect{u}_{i-1}}}\vect{u}_{i-1}</me>.</p>
                <p>Let <m>T=\set{\vectorlist{u}{p}}</m>.  Then <m>T</m> is an orthogonal set of nonzero vectors, and <m>\spn{T}=\spn{S}</m>.</p>
            </statement>
            <proof>
                <p>We will prove the result by using induction on <m>p</m> (Proof Technique<nbsp/><xref ref="technique-I" acro="I" text="global"/>).  To begin, we prove that <m>T</m> has the desired properties when <m>p=1</m>.  In this case <m>\vect{u}_1=\vect{v}_1</m> and <m>T=\set{\vect{u}_1}=\set{\vect{v}_1}=S</m>.  Because <m>S</m> and <m>T</m> are equal, <m>\spn{S}=\spn{T}</m>.  Equally trivial, <m>T</m> is an orthogonal set.  If <m>\vect{u}_1=\zerovector</m>, then <m>S</m> would be a linearly dependent set, a contradiction.</p>
                <p>Suppose that the theorem is true for any set of <m>p-1</m> linearly independent vectors.  Let <m>S=\set{\vectorlist{v}{p}}</m> be a linearly independent set of <m>p</m> vectors.  Then <m>S^\prime=\set{\vectorlist{v}{p-1}}</m> is also linearly independent.  So we can apply the theorem to <m>S^\prime</m> and construct the vectors <m>T^\prime=\set{\vectorlist{u}{p-1}}</m>.  <m>T^\prime</m> is therefore an orthogonal set of nonzero vectors and <m>\spn{S^\prime}=\spn{T^\prime}</m>.  Define<me>\vect{u}_p=\vect{v}_p
                -\frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                -\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
                -\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
                -\cdots
                -\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}</me>and let <m>T=T^\prime\cup\set{\vect{u}_p}</m>.  We need to now show that <m>T</m> has several properties by building on what we know about <m>T^\prime</m>.  But first notice that the above equation has no problems with the denominators (<m>\innerproduct{\vect{u}_i}{\vect{u}_i}</m>) being zero, since the <m>\vect{u}_i</m> are from <m>T^\prime</m>, which is composed of nonzero vectors.</p>
                <p>We show that <m>\spn{T}=\spn{S}</m>, by first establishing that <m>\spn{T}\subseteq\spn{S}</m>.  Suppose <m>\vect{x}\in\spn{T}</m>, so<me>\vect{x}=\lincombo{a}{u}{p}</me>.  The term <m>a_p\vect{u}_p</m> is a linear combination of vectors from <m>T^\prime</m> and the vector <m>\vect{v}_p</m>, while the remaining terms are a linear combination of vectors from <m>T^\prime</m>.  Since <m>\spn{T^\prime}=\spn{S^\prime}</m>, any term that is a multiple of a vector from <m>T^\prime</m> can be rewritten as a linear combination of vectors from <m>S^\prime</m>.  The remaining term <m>a_p\vect{v}_p</m> is a multiple of a vector in <m>S</m>.  So we see that <m>\vect{x}</m> can be rewritten as a linear combination of vectors from <m>S</m>, <ie/> <m>\vect{x}\in\spn{S}</m>.</p>
                <p>To show that <m>\spn{S}\subseteq\spn{T}</m>, begin with <m>\vect{y}\in\spn{S}</m>, so<me>\vect{y}=\lincombo{a}{v}{p}</me>.</p>
                <p>Rearrange our defining equation for <m>\vect{u}_p</m> by solving for <m>\vect{v}_p</m>.  Then the term <m>a_p\vect{v}_p</m> is a multiple of a linear combination of elements of <m>T</m>.  The remaining terms are a linear combination of <m>\vectorlist{v}{p-1}</m>, hence an element of <m>\spn{S^\prime}=\spn{T^\prime}</m>.  Thus these remaining terms can be written as a linear combination of the vectors in <m>T^\prime</m>.   So <m>\vect{y}</m> is a linear combination of vectors from <m>T</m>, <ie/> <m>\vect{y}\in\spn{T}</m>.</p>
                <p>The elements of <m>T^\prime</m> are nonzero, but what about <m>\vect{u}_p</m>?  Suppose to the contrary that <m>\vect{u}_p=\zerovector</m><md>
                <mrow>\zerovector&amp;=\vect{u}_p=\vect{v}_p
                -\frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                -\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
                -\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
                -\cdots
                -\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}</mrow><mrow>&amp;\vect{v}_p=
                 \frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                +\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
                +\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
                +\cdots
                +\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}</mrow></md>.</p>
                <p>Since <m>\spn{S^\prime}=\spn{T^\prime}</m> we can write the vectors <m>\vectorlist{u}{p-1}</m> on the right side of this equation in terms of the vectors <m>\vectorlist{v}{p-1}</m> and we then have the vector <m>\vect{v}_p</m> expressed as a linear combination of the other <m>p-1</m> vectors in <m>S</m>, implying that <m>S</m> is a linearly dependent set (<xref ref="theorem-DLDS" acro="DLDS"/>), contrary to our lone hypothesis about <m>S</m>.</p>
                <p>Finally, it is a simple matter to establish that <m>T</m> is an orthogonal set, though it will not appear so simple looking.  Think about your objects as you work through the following <mdash/> what is a vector and what is a scalar.  Since <m>T^\prime</m> is an orthogonal set by induction, most pairs of elements in <m>T</m> are already known to be orthogonal.  We just need to test <q>new</q> inner products, between <m>\vect{u}_p</m> and <m>\vect{u}_i</m>, for <m>1\leq i\leq p-1</m>.  Here we go, using summation notation<md>
                    <mrow>\innerproduct{\vect{u}_i}{\vect{u}_p}&amp;=
                    \innerproduct{\vect{u}_i}{
                    \vect{v}_p-\sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
                    }
                    </mrow>
                    <mrow>&amp;=
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \innerproduct{\vect{u}_i}{
                    \sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
                    }&amp;&amp;
                        <xref ref="theorem-IPVA" acro="IPVA"/></mrow>
                    <mrow>&amp;=
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \sum_{k=1}^{p-1}\innerproduct{\vect{u}_i}{
                    \frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
                    }&amp;&amp;
                        <xref ref="theorem-IPVA" acro="IPVA"/></mrow>
                    <mrow>&amp;=
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\innerproduct{\vect{u}_i}{\vect{u}_k}&amp;&amp;
                        <xref ref="theorem-IPSM" acro="IPSM"/></mrow>
                    <mrow>&amp;=
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \frac{\innerproduct{\vect{u}_i}{\vect{v}_p}}{\innerproduct{\vect{u}_i}{\vect{u}_i}}\innerproduct{\vect{u}_i}{\vect{u}_i}
                    -
                    \sum_{k\neq i}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}(0)&amp;&amp;
                        \text{Induction Hypothesis}</mrow>
                    <mrow>&amp;=
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \innerproduct{\vect{u}_i}{\vect{v}_p}
                    -
                    \sum_{k\neq i}0</mrow>
                    <mrow>&amp;=0</mrow></md>.</p>
            </proof>
        </theorem>
        <example xml:id="example-GSTV" acro="GSTV">
            <title>Gram-Schmidt of three vectors</title>
            <idx>
                <h>Gram-Schmidt</h>
                <h>three vectors</h>
            </idx>
            <p>We will illustrate the Gram-Schmidt process with three vectors.  Begin with the linearly independent (check this!) set<me>S=\set{\vect{v}_1,\,\vect{v}_2,\,\vect{v}_3}=\set{
            \colvector{1\\1+i\\1},\,
            \colvector{-i\\1\\1+i},\,
            \colvector{0\\i\\i}
            }</me>.</p>
            <p>Then<md>
                <mrow>\vect{u}_1&amp;=\vect{v_1}=\colvector{1\\1+i\\1}
                \qquad
                \vect{u}_2=\vect{v}_2
                -\frac{\innerproduct{\vect{u}_1}{\vect{v}_2}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                =\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i}</mrow>
                <mrow>\vect{u}_3&amp;=\vect{v}_3
                -\frac{\innerproduct{\vect{u}_1}{\vect{v}_3}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
                -\frac{\innerproduct{\vect{u}_2}{\vect{v}_3}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
                =\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}</mrow>
            </md>and<me>T=\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}
                =\set{
                \colvector{1\\1+i\\1},\,
                \frac{1}{4}\colvector{-2-3i\\1-i\\2+5i},\,
                \frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}
                }</me>is an orthogonal set (which you can check) of nonzero vectors and <m>\spn{T}=\spn{S}</m> (all by <xref ref="theorem-GSP" acro="GSP"/>).  Of course, as a by-product of orthogonality, the set <m>T</m> is also linearly independent (<xref ref="theorem-OSLI" acro="OSLI"/>).</p>
        </example>
        <p>One final definition related to orthogonal vectors.</p>
        <definition xml:id="definition-ONS" acro="ONS">
            <title>OrthoNormal Set</title>
            <idx>orthonormal</idx>
            <statement>
                <p>Suppose <m>S=\set{\vectorlist{u}{n}}</m> is an orthogonal set of vectors such that <m>\norm{\vect{u}_i}=1</m> for all <m>1\leq i\leq n</m>.  Then <m>S</m> is an <term>orthonormal</term> set of vectors.</p>
            </statement>
        </definition>
        <p>Once you have an orthogonal set, it is easy to convert it to an orthonormal set <mdash/> multiply each vector by the reciprocal of its norm, and the resulting vector will have norm 1.  This scaling of each vector will not affect the orthogonality properties (apply <xref ref="theorem-IPSM" acro="IPSM"/>).</p>
        <example xml:id="example-ONTV" acro="ONTV">
            <title>Orthonormal set, three vectors</title>
            <idx>
                <h>orthonormal set</h>
                <h>three vectors</h>
            </idx>
            <p>The set<me>T=\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}
            =\set{
            \colvector{1\\1+i\\1},\,
            \frac{1}{4}\colvector{-2-3i\\1-i\\2+5i},\,
            \frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}
            }</me>from <xref ref="example-GSTV" acro="GSTV"/> is an orthogonal set.</p>
            <p>We compute the norm of each vector<md>
                <mrow>\norm{\vect{u}_1}=2&amp;&amp;
                \norm{\vect{u}_2}=\frac{1}{2}\sqrt{11}&amp;&amp;
                \norm{\vect{u}_3}=\frac{\sqrt{2}}{\sqrt{11}}</mrow>.
            </md></p>
            <p>Converting each vector to a norm of <m>1</m>, yields an orthonormal set<md>
                <mrow>\vect{w}_1&amp;=\frac{1}{2}\colvector{1\\1+i\\1}
                \qquad
                \vect{w}_2=\frac{1}{\frac{1}{2}\sqrt{11}}\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i}=\frac{1}{2\sqrt{11}}\colvector{-2-3i\\1-i\\2+5i}</mrow>
                <mrow>\vect{w}_3&amp;=\frac{1}{\frac{\sqrt{2}}{\sqrt{11}}}\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}=\frac{1}{\sqrt{22}}\colvector{-3-i\\1+3i\\-1-i}</mrow>
            </md>.</p>
        </example>
        <example xml:id="example-ONFV" acro="ONFV">
            <title>Orthonormal set, four vectors</title>
            <idx>
                <h>orthonormal set</h>
                <h>four vectors</h>
            </idx>
            <p>As an exercise convert the linearly independent set<me>S=\set{
            \colvector{1+i\\1\\1-i\\i},\,
            \colvector{i\\1+i\\-1\\-i},\,
            \colvector{i\\-i\\ -1+i\\1},\,
            \colvector{-1-i\\i\\1\\-1}
            }</me>to an orthogonal set via the Gram-Schmidt Process (<xref ref="theorem-GSP" acro="GSP"/>) and then scale the vectors to norm 1 to create an orthonormal set.  You should get the same set you would if you scaled the orthogonal set of <xref ref="example-AOS" acro="AOS"/> to become an orthonormal set.</p>
        </example>
        <p>We will see orthonormal sets again in <xref ref="subsection-MINM-UM" acro="MINM.UM"/>.   They are intimately related to unitary matrices (<xref ref="definition-UM" acro="UM"/>) through <xref ref="theorem-CUMOS" acro="CUMOS"/>.  Some of the utility of orthonormal sets is captured by <xref ref="theorem-COB" acro="COB"/> in <xref ref="subsection-B-OBC" acro="B.OBC"/>.   Orthonormal sets appear once again in <xref ref="section-OD" acro="OD"/> where they are key in orthonormal diagonalization.</p>
        <computation xml:id="sage-OGS" acro="OGS">
            <title>Orthogonality and Gram-Schmidt</title>
            <idx>orthogonality and Gram-Schmidt</idx>
            <p>It is easy enough to check a pair of vectors for orthogonality (is the inner product zero?).  To check that a set is orthogonal, we just need to do this repeatedly. This is a redo of <xref ref="example-AOS" acro="AOS"/>.</p>
            <sage xml:id="sagecell-OGS-1">
                <input>
                x1 = vector(QQbar, [    1+I,       1,      1-I,       I])
                x2 = vector(QQbar, [  1+5*I,   6+5*I,     -7-I,   1-6*I])
                x3 = vector(QQbar, [-7+34*I, -8-23*I, -10+22*I, 30+13*I])
                x4 = vector(QQbar, [ -2-4*I,     6+I,    4+3*I,     6-I])
                S = [x1, x2, x3, x4]
                ips = [S[i].hermitian_inner_product(S[j])
                                  for i in range(3) for j in range(i+1,3)]
                all([ip == 0 for ip in ips])
                </input>
                <output>
                True
                </output>
            </sage>
            <p>Notice how the list comprehension computes each pair just once, and never checks the inner product of a vector with itself.  If we wanted to check that a set is orthonormal, the <q>normal</q> part is less involved.  We will check the set above, even though we can clearly see that the four vectors are not even close to being unit vectors.  Be sure to run the above definitions of <c>S</c> before running the next compute cell.</p>
            <sage xml:id="sagecell-OGS-2">
                <input>
                ips = [S[i].hermitian_inner_product(S[i]) for i in range(3)]
                all([ip == 1 for ip in ips])
                </input>
                                <output>
                False
                </output>
            </sage>
            <p>Applying the Gram-Schmidt procedure to a set of vectors is the type of computation that a program like Sage is perfect for.  Gram-Schmidt is implemented as a method for matrices, where we interpret the rows of the matrix as the vectors in the original set.  The result is two matrices, where the first has rows that are the orthogonal vectors.  The second matrix has rows that provide linear combinations of the orthogonal vectors that equal the original vectors.  The original vectors do not need to form a linearly independent set, and when the set is linearly dependent, then zero vectors produced are not part of the returned set.</p>
            <p>Over <c>CDF</c> the set is automatically orthonormal, and since a different algorithm is used (to help control the imprecisions), the results will look different than what would result from <xref ref="theorem-GSP" acro="GSP"/>.  We will illustrate with the vectors from <xref ref="example-GSTV" acro="GSTV"/>.</p>
            <sage xml:id="sagecell-OGS-3">
                <input>
                v1 = vector(CDF, [ 1, 1+I,   1])
                v2 = vector(CDF, [-I,   1, 1+I])
                v3 = vector(CDF, [ 0,   I,   I])
                A = matrix([v1,v2,v3])
                G, M = A.gram_schmidt()
                G.round(5)
                </input>
                <output>
                [                -0.5         -0.5 - 0.5*I                 -0.5]
                [ 0.30151 + 0.45227*I -0.15076 + 0.15076*I -0.30151 - 0.75378*I]
                [   0.6396 + 0.2132*I   -0.2132 - 0.6396*I    0.2132 + 0.2132*I]
                </output>
            </sage>
            <p>We formed the matrix A with the three vectors as rows, and of the two outputs we are interested in the first one, whose rows form the orthonormal set.  We round the numbers to 5 digits, just to make the result fit nicely on your screen.  Let us do it again, now exactly over <c>QQbar</c>.  We will output the entries of the matrix as list, working across rows first, so it fits nicely.</p>
            <sage xml:id="sagecell-OGS-4">
                <input>
                v1 = vector(QQbar, [ 1, 1+I,   1])
                v2 = vector(QQbar, [-I,   1, 1+I])
                v3 = vector(QQbar, [ 0,   I,   I])
                A = matrix([v1,v2,v3])
                G, M = A.gram_schmidt(orthonormal=True)
                Sequence(G.list(), cr=True)
                </input>
                <output>
                [
                0.50000000000000000?,
                0.50000000000000000? + 0.50000000000000000?*I,
                0.50000000000000000?,
                -0.3015113445777636? - 0.4522670168666454?*I,
                0.1507556722888818? - 0.1507556722888818?*I,
                0.3015113445777636? + 0.7537783614444091?*I,
                -0.6396021490668313? - 0.2132007163556105?*I,
                0.2132007163556105? + 0.6396021490668313?*I,
                -0.2132007163556105? - 0.2132007163556105?*I
                ]
                </output>
            </sage>
            <p>Notice that we asked for orthonormal output, so the rows of <c>G</c> are the vectors <m>\set{\vect{w}_1,\,\vect{w}_2,\,\vect{w}_3}</m> in <xref ref="example-ONTV" acro="ONTV"/>.  Exactly.  We can restrict ourselves to <c>QQ</c> and forego the <q>normality</q> to obtain just the orthogonal set <m>\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}</m> of <xref ref="example-GSTV" acro="GSTV"/>.</p>
            <sage xml:id="sagecell-OGS-5">
                <input>
                v1 = vector(QQbar, [ 1, 1+I,   1])
                v2 = vector(QQbar, [-I,   1, 1+I])
                v3 = vector(QQbar, [ 0,   I,   I])
                A = matrix([v1, v2, v3])
                G, M = A.gram_schmidt(orthonormal=False)
                Sequence(G.list(), cr=True)
                </input>
                <output>
                [
                1,
                I + 1,
                1,
                -0.50000000000000000? - 0.75000000000000000?*I,
                0.25000000000000000? - 0.25000000000000000?*I,
                0.50000000000000000? + 1.2500000000000000?*I,
                -0.2727272727272728? - 0.0909090909090909?*I,
                0.0909090909090909? + 0.2727272727272728?*I,
                -0.0909090909090909? - 0.0909090909090909?*I
                ]
                </output>
            </sage>
            <p>Notice that it is an error to ask for an orthonormal set over <c>QQ</c> since you cannot expect to take square roots of rationals and stick with rationals.</p>
            <sage xml:id="sagecell-OGS-6">
                <input>
                v1 = vector(QQ, [1, 1])
                v2 = vector(QQ, [2, 3])
                A = matrix([v1,v2])
                G, M = A.gram_schmidt(orthonormal=True)
                </input>
                <output>
                Traceback (most recent call last):
                ...
                TypeError: QR decomposition unable to compute square roots in Rational Field
                </output>
            </sage>
        </computation>
    </subsection>
    <exercises xml:id="readingquestions-O">
        <title>Reading Questions</title>
        <exercise xml:id="reading-O-1">
            <statement>
                <p>Is the set<me>\set{\colvector{1\\-1\\2},\,\colvector{5\\3\\-1},\,\colvector{8\\4\\-2}}</me>an orthogonal set?  Why?</p>
            </statement>
        </exercise>
        <exercise xml:id="reading-O-2">
            <statement>
                <p>What is the distinction between an orthogonal set and an orthonormal set?</p>
            </statement>
        </exercise>
        <exercise xml:id="reading-O-3">
            <statement>
                <p> What is nice about the output of the Gram-Schmidt process?</p>
            </statement>
        </exercise>
    </exercises>
    <exercises xml:id="exercises-O">
        <title>Exercises</title>
        <exercise number="C20" xml:id="exercise-O-C20">
            <statement>
                <p>Complete <xref ref="example-AOS" acro="AOS"/> by verifying that the four remaining inner products are zero.</p>
            </statement>
        </exercise>
        <exercise number="C21" xml:id="exercise-O-C21">
            <statement>
                <p>Verify that the set <m>T</m> created in <xref ref="example-GSTV" acro="GSTV"/> by the Gram-Schmidt Procedure is an orthogonal set.</p>
            </statement>
        </exercise>
        <exercise number="M60" xml:id="exercise-O-M60">
            <statement contributor="manleyperkel">
                <p>Suppose that <m>\set{\vect{u},\,\vect{v},\,\vect{w}}\subseteq\complex{n}</m> is an orthonormal set.  Prove that <m>\vect{u}+\vect{v}</m> is not orthogonal to <m>\vect{v}+\vect{w}</m>.</p>
            </statement>
        </exercise>
        <exercise number="T10" xml:id="exercise-O-T10">
            <statement>
                <p>Prove part 2 of the conclusion of <xref ref="theorem-IPVA" acro="IPVA"/>.</p>
            </statement>
        </exercise>
        <exercise number="T11" xml:id="exercise-O-T11">
            <statement>
                <p>Prove part 2 of the conclusion of <xref ref="theorem-IPSM" acro="IPSM"/>.</p>
            </statement>
        </exercise>
        <exercise number="T20" xml:id="exercise-O-T20">
            <statement>
                <p>Suppose that <m>\vect{u},\,\vect{v},\,\vect{w}\in\complex{n}</m>, <m>\alpha,\,\beta\in\complexes</m> and <m>\vect{u}</m> is orthogonal to both <m>\vect{v}</m> and <m>\vect{w}</m>.  Prove that <m>\vect{u}</m> is orthogonal to <m>\alpha\vect{v}+\beta\vect{w}</m>.</p>
            </statement>
            <solution xml:id="solution-O-T20">
                <p>Vectors are orthogonal if their inner product is zero (<xref ref="definition-OV" acro="OV"/>), so we compute<md>
                    <mrow>\innerproduct{\vect{u}}{\alpha\vect{v}+\beta\vect{w}}
                    &amp;=
                    \innerproduct{\vect{u}}{\alpha\vect{v}}+
                    \innerproduct{\vect{u}}{\beta\vect{w}}
                    &amp;&amp;<xref ref="theorem-IPVA" acro="IPVA"/></mrow>
                    <mrow>&amp;=
                    \alpha\innerproduct{\vect{u}}{\vect{v}}+
                    \beta\innerproduct{\vect{u}}{\vect{w}}
                    &amp;&amp;<xref ref="theorem-IPSM" acro="IPSM"/></mrow>
                    <mrow>&amp;=
                    \alpha\left(0\right)+\beta\left(0\right)
                    &amp;&amp;<xref ref="definition-OV" acro="OV"/></mrow>
                    <mrow>&amp;=0</mrow>
                </md>.  So by <xref ref="definition-OV" acro="OV"/>, <m>\vect{u}</m> and <m>\alpha\vect{v}+\beta\vect{w}</m> are an orthogonal pair of vectors.</p>
            </solution>
        </exercise>
        <exercise number="T30" xml:id="exercise-O-T30">
            <statement contributor="stevecanfield">
                <p>Suppose that the set <m>S</m> in the hypothesis of <xref ref="theorem-GSP" acro="GSP"/> is not just linearly independent, but is also orthogonal.  Prove that the set <m>T</m> created by the Gram-Schmidt procedure is equal to <m>S</m>.  (Note that we are getting a stronger conclusion than <m>\spn{T}=\spn{S}</m> <mdash/> the conclusion is that <m>T=S</m>.)  In other words, it is pointless to apply the Gram-Schmidt procedure to a set that is already orthogonal.</p>
            </statement>
        </exercise>
        <!-- Question suggested by Chili Johnson, Spring 2015 -->
        <exercise number="T31" xml:id="exercise-O-T31">
            <statement>
                <p>Suppose that the set <m>S</m> is linearly independent. Apply the Gram-Schmidt procedure (<xref ref="theorem-GSP" acro="GSP"/>) twice, creating first the linearly independent set <m>T_1</m> from <m>S</m>, and then creating <m>T_2</m> from <m>T_1</m>.  As a consequence of <xref ref="exercise-O-T30" acro="O.T30"/>, prove that <m>T_1=T_2</m>.  In other words, it is pointless to apply the Gram-Schmidt procedure twice.</p>
            </statement>
        </exercise>
    </exercises>
</section>
